Assumptions and parameters:
- dimensions: mxn
- mn initial states
- Map<Integer, Cell> cells initialized
- Cell indices are numbered 1->mn

for (int i = 1; i <= m; i++) {
	for (int j = 1; j <= n; j++) {
		int curr_index = n(i-1) + j;
		List<Cell> neighbors = new List<Cell>();
		Cell c = cells.get(curr_index);
		// handle up
		int up_index = curr_index - n;
		if (up_index > 0) {
			neighbors.add(cells.get(up_index));
		}
		// handle upright
		int upright_index = curr_index - n + 1;
		if (upright_index > 0 && upright_index % n != 1) {
			neighbors.add(cells.get(upright_index));
		}
		// handle right
		int right_index = curr_index + 1;
		if (right_index % n != 1) {
			neighbors.add(cells.get(right_index));
		}
		// handle rightdown
		int rightdown_index = curr_index + n + 1; 
		if (rightdown_index <= mn && rightdown_index % n != 1) {
			neighbors.add(cells.get(rightdown_index));
		}
		// handle down
		int down_index = curr_index + n;
		if (down_index <= mn) {
			neighbors.add(cells.get(down_index));
		}
		// handle downleft
		int downleft_index = curr_index + n - 1;
		if (downleft_index <= mn && downleft_index % n != 0) {
			neighbors.add(cells.get(downleft_index));
		}
		//handle left
		int left_index = curr_index - 1;
		if (left_index % n != 0) {
			neighbors.add(cells.get(left_index));
		}
		// handle upleft
		index upleft_index = curr_index - n - 1;
		if (upleft_index > 0 && upleft_index % n != 0) {
			neighbors.add(cells.get(upleft_index));
		}
		c.addNeighbors(neighbors);
	}
}